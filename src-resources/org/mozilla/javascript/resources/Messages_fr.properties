#
# French JavaScript messages file.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# Codegen
msg.dup.parms =\
    Le nom de param\u00E8tre "{0}" existe d\u00E9j\u00E0.

msg.too.big.jump =\
    Programme trop complexe: d\u00E9calage de saut trop important

msg.too.big.index =\
    Programme trop complexe: l''indice interne d\u00E9passe la limite de 64\u00a0ko

msg.while.compiling.fn =\
    Une erreur de g\u00e9n\u00e9ration de code a \u00e9t\u00e9 rencontr\u00e9e \u00e0 la compilation de la fonction "{0}": {1}

msg.while.compiling.script =\
    Une erreur de g\u00e9n\u00e9ration de code a \u00e9t\u00e9 rencontr\u00e9e \u00e0 la compilation du script: {0}

# Context
msg.ctor.not.found =\
    Le constructeur de "{0}" est introuvable

msg.not.ctor =\
    {0} n''est pas un constructeur

# FunctionObject
msg.varargs.ctor =\
    La m\u00E9thode ou le constructeur "{0}" doit \u00EAtre statique avec la signature \
    "(Context cx, Object[] args, Function ctorObj, boolean inNewExpr)" \
    pour d\u00E9finir un constructeur d''arguments de variable.

msg.varargs.fun =\
    La m\u00E9thode "{0}" doit \u00EAtre statique avec la signature \
    "(Context cx, Scriptable thisObj, Object[] args, Function funObj)" \
    pour d\u00E9finir une fonction d''arguments de variable

msg.incompat.call =\
    La m\u00E9thode "{0}" a \u00E9t\u00E9 appel\u00E9e dans un objet non compatible

msg.bad.parms =\
    Les param\u00E8tres de la m\u00E9thode sont incorrects pour "{0}"

msg.bad.method.return =\
    Le type de retour "{0}" de la m\u00e9thode "{1}" est incorrect.

msg.bad.ctor.return =\
    La construction d''objets du type "{0}" n''est pas possible.

msg.no.overload =\
    La m\u00E9thode "{0}" appara\u00EEt plusieurs fois dans la classe "{1}"

msg.method.not.found =\
    La m\u00E9thode "{0}" est introuvable dans "{1}"

# IRFactory

msg.bad.for.in.lhs =\
    La partie gauche de la boucle for..in est incorrecte

msg.mult.index =\
    Une seule variable est autoris\u00E9e dans la boucle for..in

msg.bad.for.in.destruct =\
    La partie gauche de la boucle for..in doit \u00eatre un tableau de longueur 2 pour accepter \
    une paire clef/valeur.

msg.cant.convert =\
    La conversion en type "{0}" est impossible

msg.bad.assign.left =\
    La partie gauche de l''affectation est incorrecte

msg.bad.decr =\
    L''op\u00e9rande d\u00e9cr\u00e9ment\u00e9e est incorrecte.

msg.bad.incr =\
    L''op\u00e9rande incr\u00e9ment\u00e9e est incorrecte.

msg.bad.yield =\
    ''yield'' doit \u00eatre dans une fonction.

msg.yield.parenthesized =\
    L''expression suivant ''yield'' doit \u00eatre entre parenth\u00e8ses.

# NativeGlobal
msg.cant.call.indirect =\
    La fonction "{0}" doit \u00EAtre appel\u00E9e directement et non par l''interm\u00E9diaire \
    d''une fonction portant un autre nom

msg.eval.nonstring =\
    Si vous appelez la fonction eval() avec une valeur qui n''est pas \u00E0 une cha\u00EEne primitive, \
    c''est la valeur en question qui est renvoy\u00E9e. \u00E9tait-ce votre intention?

msg.eval.nonstring.strict =\
    La fonction eval() ne peut \u00eatre appel\u00e9e avec une valeur autre qu'une cha\u00EEne primitive \
    en mode strict

msg.bad.destruct.op =\
    L''op\u00e9rateur de l''assignation d\u00e9structurante est incorrect

# NativeCall
msg.only.from.new =\
    {0} ne peut \u00EAtre appel\u00E9e qu''\u00E0 partir d''une "nouvelle" expression.

msg.deprec.ctor =\
    Le constructeur "{0}" est d\u00E9conseill\u00E9

# NativeFunction
msg.no.function.ref.found =\
    aucune source n''a \u00E9t\u00E9 trouv\u00E9e pour d\u00E9compiler la r\u00E9f\u00E9rence de fonction {0}

msg.arg.isnt.array =\
    le second argument de la m\u00E9thode Function.prototype.apply doit \u00EAtre un tableau

# NativeGlobal
msg.bad.esc.mask =\
    le masque d''\u00E9chappement de cha\u00EEne est incorrect

# NativeJavaClass
msg.cant.instantiate =\
    erreur lors de l''instanciation ({0}): la classe {1} est une classe interface ou abstract

msg.bad.ctor.sig =\
    Un constructeur avec une signature incorrecte a \u00E9t\u00E9 d\u00E9tect\u00E9: \
    {0} qui appelle {1} avec la signature {2}

msg.not.java.obj =\
    L''argument attendu pour la fonction getClass() doit \u00EAtre un objet Java

msg.no.java.ctor =\
    Le constructeur Java de "{0}" avec les arguments "{1}" est introuvable

# NativeJavaMethod
msg.method.ambiguous =\
    Le choix de la m\u00E9thode Java {0}.{1} correspondant aux types d''argument JavaScript ({2}) est ambigu. \
    Les m\u00E9thodes propos\u00E9es sont les suivantes: {3}

msg.constructor.ambiguous =\
    Le choix du constructeur Java {0} correspondant aux types d''argument JavaScript ({1}) est ambigu. \
    Les constructeurs propos\u00E9s sont les suivants: {2}

# NativeJavaObject
msg.conversion.not.allowed =\
    Impossible de convertir {0} en {1}

msg.no.empty.interface.conversion =\
    Impossible de convertir la fonction en interface {0} sans aucune m\u00e9thode

msg.no.function.interface.conversion =\
    Impossible de convertir la fonction {0} en interface puisqu'elle contient des m\u00e9thodes avec \
    des noms diff\u00e9rentes

msg.undefined.function.interface =\
    La propri\u00E9t\u00E9 "{0}" n''est pas d\u00E9finie dans l''adaptateur d''interface

msg.not.function.interface =\
    La propri\u00E9t\u00E9 "{0}" n''est pas une fonction dans l''adaptateur d''interface

# NativeJavaPackage
msg.not.classloader =\
    Le constructeur de "Packages" attend un argument de type java.lang.Classloader

# NativeRegExp
msg.bad.quant =\
    Le quantificateur {0} est incorrect

msg.overlarge.backref =\
    La r\u00e9f\u00e9rence ant\u00e9rieure est trop importante {0}

msg.overlarge.min =\
    Le minimum {0} est trop important

msg.overlarge.max =\
    Le maximum {0} est trop important

msg.zero.quant =\
    Le quantificateur {0} est nul

msg.max.lt.min =\
    Le maximum {0} est inf\u00E9rieur au minimum

msg.unterm.quant =\
    Le quantificateur {0} n''a pas de limite

msg.unterm.paren =\
    Les parenth\u00E8ses {0} n''ont pas de limite

msg.unterm.class =\
    La classe de caract\u00E8res {0} n''a pas de limite

msg.bad.range =\
    La classe de caract\u00E8res contient une plage de valeurs incorrecte

msg.trail.backslash =\
    \\ \u00e0 la fin d''une expression rationnelle

msg.re.unmatched.right.paren =\
    Parenth\u00e8se fermante orpheline dans l'expression rationnelle

msg.no.regexp =\
    Les expressions rationnelles ne sont pas disponibles

msg.bad.backref =\
    la r\u00E9f\u00E9rence ant\u00E9rieure d\u00E9passe le nombre de parenth\u00E8ses de capture

msg.bad.regexp.compile =\
    Un seul argument peut \u00eatre sp\u00e9cifi\u00e9 si le premier argument de \
    RegExp.prototype.compile est un objet de type RegExp.

msg.arg.not.object =\
    L''argument attendu est de type ''object'' au lieu de ''{0}''

# NativeDate
msg.invalid.date =\
    Date incorrecte.

msg.toisostring.must.return.primitive =\
    toISOString doit renvoyer une valeur primitive, mais a retourn\u00e9 \u00e0 la place "{0}"

# Parser
msg.got.syntax.errors = \
    La compilation a produit {0} erreur(s) de syntaxe.

msg.var.redecl =\
    Erreur de type: la variable "{0}" a \u00e9t\u00e9 de nouveau d\u00e9clar\u00e9e.

msg.const.redecl =\
    Erreur de type: la constante "{0}" a \u00e9t\u00e9 de nouveau d\u00e9clar\u00e9e.

msg.let.redecl =\
    Erreur de type: la variable "{0}" a \u00e9t\u00e9 de nouveau d\u00e9clar\u00e9e.

msg.parm.redecl =\
    Erreur de type: le param\u00e8tre formel "{0}" a \u00e9t\u00e9 de nouveau d\u00e9clar\u00e9.

msg.fn.redecl =\
    Erreur de type: la fonction "{0}" a \u00E9t\u00E9 de nouveau d\u00E9clar\u00E9e.

msg.let.decl.not.in.block =\
    Erreur de syntaxe: la d\u00e9claration ''let'' n''est pas directement dans un block

msg.bad.object.init =\
    Erreur de syntaxe: initialiseur d'objet incorrect

# NodeTransformer
msg.dup.label =\
    Le libell\u00E9 {0} existe d\u00E9j\u00E0

msg.undef.label =\
    Le libell\u00E9 {0} n''est pas d\u00E9fini

msg.bad.break =\
    Le saut non libell\u00E9 doit se trouver dans une boucle ou un switch

msg.continue.outside =\
    continue doit se trouver dans la boucle

msg.continue.nonloop =\
    Il n''est possible de continuer que dans l''instruction d''it\u00E9ration libell\u00E9e

msg.bad.throw.eol =\
    Un retour \u00e0 la ligne n''est pas autoris\u00e9 entre un mot-clef throw et son \
    expression.

msg.no.paren.parms =\
    il manque ''('' avant les param\u00E8tres de la fonction

msg.no.parm =\
    il manque un param\u00E8tre formel

msg.no.paren.after.parms =\
    il manque '')'' apr\u00E8s les param\u00E8tres formels

msg.no.brace.body =\
    il manque ''{'' avant le corps d''une fonction

msg.no.brace.after.body =\
    il manque ''}'' apr\u00E8s le corps d''une fonction

msg.no.paren.cond =\
    il manque ''('' avant une condition

msg.no.paren.after.cond =\
    il manque '')'' apr\u00E8s une condition

msg.no.semi.stmt =\
    il manque '';'' avant une instruction

msg.missing.semi =\
    il manque '';'' apr\u00e8s une instruction

msg.no.name.after.dot =\
    il manque un nom apr\u00E8s un op\u00E9rateur ''.''

msg.no.name.after.coloncolon =\
    il manque un nom apr\u00e8s un op\u00e9rateur ''::''

msg.no.name.after.dotdot =\
    il manque un nom apr\u00e8s un op\u00e9rateur ''..''

msg.no.name.after.xmlAttr =\
    il manque un nom apr\u00e8s ''.@''

msg.no.bracket.index =\
    il manque '']'' dans l''expression de l''indice

msg.no.paren.switch =\
    il manque ''('' avant l''expression du switch

msg.no.paren.after.switch =\
    il manque '')'' apr\u00E8s l''expression du switch

msg.no.brace.switch =\
    il manque ''{'' avant le corps du switch

msg.bad.switch =\
    l''instruction switch est incorrecte

msg.no.colon.case =\
    il manque '':'' apr\u00E8s l''expression d''un cas

msg.double.switch.default =\
    le libell\u00e9 ''default'' appara\u00eet plusieurs fois dans le bloc switch

msg.no.while.do =\
    il manque ''while'' apr\u00E8s le corps d''une boucle do-loop

msg.no.paren.for =\
    il manque ''('' apr\u00E8s for

msg.no.semi.for =\
    Il manque '';'' apr\u00E8s l''initialiseur for-loop

msg.no.semi.for.cond =\
    il manque '';'' apr\u00E8s la condition for-loop

msg.in.after.for.name =\
    il manque le mot-clef ''in'' apr\u00e8s ''for''

msg.no.paren.for.ctrl =\
    il manque '')'' apr\u00E8s le contr\u00f4le for-loop

msg.no.paren.with =\
    il manque ''('' avant un objet with-statement

msg.no.paren.after.with =\
    il manque '')'' apr\u00E8s un objet with-statement

msg.no.with.strict =\
    L'instruction with n''est pas autoris\u00e9e en mode strict

msg.no.paren.after.let =\
    il manque ''('' apr\u00e8s let

msg.no.paren.let =\
    il manque '')'' apr\u00e8s la liste de variables

msg.no.curly.let =\
    il manque ''}'' apr\u00e8s l'instruction let

msg.bad.return =\
    la valeur renvoy\u00E9e est incorrecte

msg.no.brace.block =\
    il manque ''}'' dans une instruction compos\u00E9e

msg.bad.label =\
    le libell\u00E9 est incorrect

msg.bad.var =\
    il manque un nom de variable

msg.bad.var.init =\
    l''initialisation de la variable est incorrecte

msg.no.colon.cond =\
    il manque '':'' dans une expression conditionnelle

msg.no.paren.arg =\
    il manque '')'' apr\u00E8s une liste d''arguments

msg.no.bracket.arg =\
    il manque '']'' apr\u00E8s une liste d''\u00E9l\u00E9ments

msg.bad.prop =\
    l''identifiant de propri\u00E9t\u00E9 est incorrect

msg.no.colon.prop =\
    il manque '':'' apr\u00E8s un identifiant de propri\u00E9t\u00E9

msg.no.brace.prop =\
    il manque ''}'' apr\u00E8s une liste de propri\u00E9t\u00E9s

msg.no.paren =\
    il manque '')'' dans des parenth\u00E8ses

msg.reserved.id =\
    l''identifiant est un mot r\u00E9serv\u00E9

msg.no.paren.catch =\
    il manque ''('' avant une condition catch-block

msg.bad.catchcond =\
    la condition catch-block est incorrecte

msg.catch.unreachable =\
    aucune clause catch suivant une interception non qualifi\u00E9e ne peut \u00EAtre atteinte

msg.no.brace.try =\
    il manque ''{'' avant le bloc try

msg.no.brace.catchblock =\
    il manque ''{'' avant le corps catch-block

msg.try.no.catchfinally =\
    ''try'' a \u00E9t\u00E9 d\u00E9tect\u00E9 sans ''catch'' ni ''finally''

msg.no.return.value =\
    la fonction {0} ne renvoie pas toujours de valeur

msg.anon.no.return.value =\
    la fonction anonyme ne renvoie pas toujours de valeur

msg.return.inconsistent =\
    l'instruction return est incoh\u00e9rente avec les usages pr\u00e9c\u00e9dents

msg.generator.returns =\
    Erreur de type: la fonction g\u00e9n\u00e9ratrice {0} renvoie une valeur

msg.anon.generator.returns =\
    Erreur de type: la fonction g\u00e9n\u00e9ratrice anonyme renvoie une valeur

msg.syntax =\
    erreur de syntaxe

msg.unexpected.eof =\
    Fin de fichier inattendue

msg.XML.bad.form =\
    la syntaxe XML est mal form\u00e9e

msg.XML.not.available =\
    L''interpr\u00e9tation du XML n''est pas disponible

msg.too.deep.parser.recursion =\
    R\u00e9cursion trop profonde pendant l''analyse

msg.too.many.constructor.args =\
    Le constructeur a trop d''arguments

msg.too.many.function.args =\
    La fonction a trop d''arguments

msg.no.side.effects =\
    Le code n''a pas de valeur de retour

msg.extra.trailing.semi =\
    Point virgule superflux \u00e0 la fin

msg.extra.trailing.comma =\
    Une virgule \u00e0 la fin d''un initialiseur d''objet n''est pas autoris\u00e9 par le standard ECMA-262

msg.trailing.array.comma =\
    Une virgule \u00e0 la fin d''un tableau lit\u00e9ral a un comportement diff\u00e9rent suivant le navigateur utilis\u00e9

msg.equal.as.assign =\
    Le test d''\u00e9galit\u00e9 (==) a t''il \u00e9t\u00e9 saisi par erreur comme une assignation (=) ?

msg.var.hides.arg =\
    La variable {0} masque un argument

msg.destruct.assign.no.init =\
    Il manque ''='' dans l''assignation d\u00e9structurante

msg.no.octal.strict =\
    Les nombres octaux ne sont pas autoris\u00e9s en mode strict.

msg.dup.obj.lit.prop.strict =\
    La propri\u00e9t\u00e9 "{0}" est d\u00e9j\u00e0 d\u00e9finie dans cet objet lit\u00e9ral.

msg.dup.param.strict =\
    Le param\u00e8tre "{0}" est d\u00e9j\u00e0 d\u00e9clar\u00e9 dans cette fonction.

msg.bad.id.strict =\
    "{0}" n''est pas un identifiant valide pour cet usage en mode strict.

# ScriptRuntime

# is there a better message for this? 
# it's currently only used as a poison pill for caller, caller and arguments properties
msg.op.not.allowed =\
    Cette op\u00e9ration n''est pas autoris\u00e9e.

msg.no.properties =\
    {0} n''a pas de propri\u00e9t\u00e9s.

msg.invalid.iterator =\
    La valeur n''est pas un it\u00e9rateur valide

msg.iterator.primitive =\
    __iterator__ a renvoy\u00e9 une valeur primitive

msg.assn.create.strict =\
    Assignation d''une variable non d\u00e9clar\u00e9e: {0}

msg.ref.undefined.prop =\
    R\u00e9f\u00e9rence \u00e0 une propri\u00e9t\u00e9 non d\u00e9finie "{0}"

msg.prop.not.found =\
    La propri\u00E9t\u00E9 est introuvable

msg.set.prop.no.setter =\
    Impossible de changer la propri\u00e9t\u00e9 ''{0}'' en l''absence de m\u00e9thode de d\u00e9finition.

msg.invalid.type =\
    Valeur JavaScript de type {0} incorrecte

msg.primitive.expected =\
    Un type primitif \u00E9tait attendu (et non {0})

msg.namespace.expected =\
    Un espace de nom est attendu \u00e0 gauche de :: ({0} trouv\u00e9 \u00e0 la place)

msg.null.to.object =\
    Il est impossible de convertir la valeur null en objet

msg.undef.to.object =\
    Il est impossible de convertir une valeur non d\u00E9finie en objet

msg.cyclic.value =\
 La valeur cyclique {0} n''est pas autoris\u00E9e

msg.is.not.defined =\
    "{0}" n''est pas d\u00E9fini

msg.undef.prop.read =\
    Impossible de lire la propri\u00e9t\u00e9 "{1}" de {0}

msg.undef.prop.write =\
    Impossible de changer la propri\u00e9t\u00e9 "{1}" de {0} en "{2}"

msg.undef.prop.delete =\
    Impossible de supprimer la propri\u00e9t\u00e9 "{1}" de {0}

msg.undef.method.call =\
    Impossible d'appeler la m\u00e9thode "{1}" de {0}

msg.undef.with =\
    Impossible d'appliquer "with" \u00e0 {0}

msg.isnt.function =\
    {0} n''est pas une fonction, c''est un {1}

msg.isnt.function.in =\
    Impossible d'appeler la propri\u00e9t\u00e9 {0} de l'objet {1}. Ce n''est pas une fonction, c''est un "{2}".

msg.function.not.found =\
    Impossible de trouver la fonction {0}.

msg.function.not.found.in =\
    Impossible de trouver la fonction {0} dans l'objet {1}.

msg.isnt.xml.object =\
    {0} n''est pas un objet xml.

msg.no.ref.to.get =\
    {0} n''est pas une r\u00e9f\u00e9rence vers une m\u00e9thode d''obtention.

msg.no.ref.to.set =\
    {0} n''est pas une r\u00e9f\u00e9rence vers une m\u00e9thode de d\u00e9finition.

msg.no.ref.from.function =\
    La fonction {0} ne peut pas \u00eatre utilis\u00e9e comme la partie gauche de l''assignation \
    ou comme l'op\u00e9rande de l''op\u00e9rateur ++ ou --.

msg.bad.default.value =\
    La m\u00E9thode getDefaultValue() de l''objet a renvoy\u00E9 un objet

msg.instanceof.not.object =\
    Il est impossible d''utiliser une instance d''un \u00E9l\u00E9ment autre qu''un objet

msg.instanceof.bad.prototype =\
    La propri\u00E9t\u00E9 ''prototype'' de {0} n''est pas un objet

msg.in.not.object = \
    Il est impossible d''utiliser une instance d''un \u00E9l\u00E9ment autre qu''un objet

msg.bad.radix =\
    la base {0} n''est pas autoris\u00E9e

# ScriptableObject
msg.default.value =\
    La valeur par d\u00E9faut de l''objet est introuvable

msg.zero.arg.ctor =\
    Il est impossible de charger la classe "{0}", qui ne poss\u00E8de pas de constructeur de param\u00E8tre z\u00E9ro

duplicate.defineClass.name =\
    M\u00e9thode "{0}" incorrecte: le nom "{1}" est d\u00e9j\u00e0 utilis\u00e9.

msg.ctor.multiple.parms =\
    Il est impossible de d\u00E9finir le constructeur ou la classe {0} car plus d''un \
    constructeur poss\u00E8de plusieurs param\u00E8tres

msg.extend.scriptable =\
    {0} doit \u00E9tendre ScriptableObject afin de d\u00E9finir la propri\u00E9t\u00E9 {1}

msg.bad.getter.parms =\
    Pour d\u00E9finir une propri\u00E9t\u00E9, la m\u00E9thode d''obtention {0} doit avoir des param\u00E8tres z\u00E9ro \
    ou un seul param\u00E8tre ScriptableObject

msg.obj.getter.parms =\
    La m\u00E9thode d''obtention statique ou d\u00E9l\u00E9gu\u00E9e {0} doit utiliser un param\u00E8tre ScriptableObject

msg.getter.static =\
    La m\u00E9thode d''obtention et la m\u00E9thode de d\u00E9finition doivent toutes deux avoir le m\u00EAme \u00E9tat (statique ou non)

msg.setter.return =\
    La m\u00e9thode de d\u00e9finition doit avoir un type de retour vide: {0}

msg.setter2.parms =\
    La m\u00E9thode de d\u00E9finition \u00E0 deux param\u00E8tres doit utiliser un param\u00E8tre ScriptableObject comme premier param\u00E8tre

msg.setter1.parms =\
    Une m\u00E9thode d''obtention \u00E0 param\u00E8tre unique est attendue pour {0}

msg.setter2.expected =\
    La m\u00E9thode de d\u00E9finition statique ou d\u00E9l\u00E9gu\u00E9e {0} doit utiliser deux param\u00E8tres

msg.setter.parms =\
    Un ou deux param\u00E8tres sont attendus pour la m\u00E9thode de d\u00E9finition

msg.setter.bad.type =\
    Le type de param\u00e8tre "{0}" est incorrect dans la m\u00e9thode de d\u00e9finition "{1}".

msg.add.sealed =\
    Il est impossible d''ajouter une propri\u00E9t\u00E9 \u00E0 un objet scell\u00E9: {0}.

msg.remove.sealed =\
    Il est impossible de supprimer une propri\u00E9t\u00E9 d''un objet scell\u00E9: {0}.

msg.modify.sealed =\
    Il est impossible de modifier une propri\u00e9t\u00e9 d''un objet scell\u00E9: {0}.

msg.modify.readonly =\
    Il est impossible de modifier une propri\u00e9t\u00e9 en lecture seule: {0}.

msg.both.data.and.accessor.desc =\
    Le descripteur ne peut pas d\u00e9finir \u00e0 la fois un accesseur et une donn\u00e9e.

msg.change.configurable.false.to.true =\
    Impossible de changer de false \u00e0 true l''attribut ''configurable'' de "{0}".

msg.change.enumerable.with.configurable.false =\
    Impossible de changer l''attribut ''enumerable'' de "{0}" car ''configurable'' est ''false''.

msg.change.writable.false.to.true.with.configurable.false =\
    Impossible de changer de false \u00e0 true l''attribut ''writable'' de "{0}" car ''configurable'' est ''false''.

msg.change.value.with.writable.false =\
    Impossible de changer la valeur de l''attribut "{0}" car ''writable'' est ''false''.

msg.change.getter.with.configurable.false =\
    Impossible de changer l''attribut get de "{0}" car ''configurable'' est ''false''.

msg.change.setter.with.configurable.false =\
    Impossible de changer l''attribut set de "{0}" car ''configurable'' est ''false''.

msg.change.property.data.to.accessor.with.configurable.false =\
    Impossible de changer la propri\u00e9t\u00e9 par donn\u00e9e "{0}" en propri\u00e9t\u00e9 par accesseur car ''configurable'' est ''false''

msg.change.property.accessor.to.data.with.configurable.false =\
    Impossible de changer la propri\u00e9t\u00e9 par accesseur "{0}" en propri\u00e9t\u00e9 par donn\u00e9e car ''configurable'' est ''false''

msg.not.extensible =\
    Impossible d''ajouter des propri\u00e9t\u00e9s \u00e0 cet objet car ''extensible'' est ''false''.

# TokenStream
msg.missing.exponent =\
    il manque un exposant

msg.caught.nfe =\
    erreur de format de nombre: {0}

msg.unterminated.string.lit =\
    le litt\u00E9ral de la cha\u00EEne n''a pas de limite

msg.unterminated.comment =\
    le commentaire n''a pas de limite

msg.unterminated.re.lit =\
    le litt\u00E9ral de l''expression rationnelle n''a pas de limite

msg.invalid.re.flag =\
    une expression rationnelle est suivie d''un indicateur incorrect

msg.no.re.input.for =\
    il n''y a pas d''entr\u00E9e pour {0}

msg.illegal.character =\
    caract\u00E8re non autoris\u00E9

msg.invalid.escape =\
    la s\u00E9quence d''\u00E9chappement Unicode est incorrecte

msg.bad.namespace =\
    L''instruction ''default xml namespace'' est incorrecte. \
    La syntaxe est: default xml namespace = EXPRESSION;

# TokensStream warnings
msg.bad.octal.literal =\
    le chiffre octal du litt\u00E9ral, {0}, n''est pas autoris\u00E9 et sera interpr\u00E9t\u00E9 comme un chiffre d\u00E9cimal

msg.reserved.keyword =\
    l''utilisation du futur mot-cl\u00E9 r\u00E9serv\u00E9 {0} n''est pas autoris\u00E9e et celui-ci sera interpr\u00E9t\u00E9 comme un identifiant ordinaire

# LiveConnect errors
msg.java.internal.field.type =\
    Erreur interne: la conversion de type de {0} afin d''affecter {1} \u00E0 {2} a \u00E9chou\u00E9

msg.java.conversion.implicit_method =\
    La m\u00E9thode de conversion "{0}" est introuvable dans la classe {1}

msg.java.method.assign =\
    La m\u00E9thode Java "{0}" ne peut pas \u00EAtre affect\u00E9e \u00E0

msg.java.internal.private =\
    Erreur interne: une tentative d''acc\u00E9der \u00E0 un champ "{0}" priv\u00E9/prot\u00E9g\u00E9 a \u00E9t\u00E9 d\u00E9tect\u00E9e

msg.java.no_such_method =\
    La m\u00E9thode ''{0}'' est introuvable

msg.script.is.not.constructor =\
    Les objets Script ne sont pas des constructeurs

msg.nonjava.method =\
    La m\u00E9thode Java "{0}" a \u00E9t\u00E9 appel\u00E9e avec une valeur ''this'' qui n''est pas un objet Java

msg.java.member.not.found =\
    La classe Java "{0}" ne poss\u00E8de aucun champ ou aucune m\u00E9thode d''instance publique appel\u00E9 "{1}"

msg.java.array.index.out.of.bounds =\
    L''indice {0} du tableau est en dehors de l''intervalle [0..{1}].

msg.java.array.member.not.found =\
    Les tableaux Java n''ont pas de champs ou de m\u00e9thodes publiques "{0}".

msg.pkg.int =\
    Les noms de package Java ne peuvent pas \u00EAtre des nombres

msg.access.prohibited =\
    L''acc\u00e8s \u00e0 la classe Java "{0}" est prohib\u00e9.

# ImporterTopLevel
msg.ambig.import =\
    Importation ambigu\u00EB: "{0}" et "{1}"

msg.not.pkg =\
    La fonction importPackage doit \u00EAtre appel\u00E9e avec un package et non avec "{0}"

msg.not.class =\
    La fonction importClass doit \u00EAtre appel\u00E9e avec une classe et non avec "{0}"

msg.not.class.not.pkg =\
    "{0}" n''est ni une classe ni un package.

msg.prop.defined =\
    Il est impossible d''importer "{0}" car une propri\u00E9t\u00E9 portant le m\u00EAme nom a d\u00E9j\u00E0 \u00E9t\u00E9 d\u00E9finie

#JavaAdapter
msg.adapter.zero.args =\
    JavaAdapter n\u00e9cessite au moins un argument.

msg.not.java.class.arg = \
    L''argument {0} n''est pas une classe Java: {1}.

#JavaAdapter
msg.only.one.super = \
    Un JavaAdapter ne peut \u00e9tendre qu'une seule classe. Les classes {0} et {1} ont \u00e9t\u00e9 donn\u00e9es.


# Arrays
msg.arraylength.bad =\
    La longueur du tableau n''est pas appropri\u00E9e

# Arrays
msg.arraylength.too.big =\
    La longueur du tableau {0} d\u00e9passe la capacit\u00e9 limite.

msg.empty.array.reduce =\
    La m\u00e9thode ''reduce'' ne fonctionne pas sans valeur initiale sur un tableau vide

# URI
msg.bad.uri =\
    La s\u00E9quence URI n''est pas form\u00E9e correctement

# Number
msg.bad.precision =\
    La pr\u00E9cision {0} ne se trouve pas dans la plage de valeurs

# NativeGenerator
msg.send.newborn =\
    La m\u00e9thode send() d''un g\u00e9n\u00e9rateur ne peut \u00eatre appel\u00e9e avant un premier appel \u00e0 next()

msg.already.exec.gen =\
    Le g\u00e9n\u00e9rateur est d\u00e9j\u00e0 en cours d''ex\u00e9cution
    
msg.StopIteration.invalid =\
    L''exception StopIteration ne peut pas \u00eatre chang\u00e9e en un objet arbitraire.

# Interpreter
msg.yield.closing =\
    yield impossible quand le g\u00e9n\u00e9rateur est en train de se fermer
